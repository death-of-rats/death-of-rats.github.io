<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Death Of Rats</title><link>https://death-of-rats.github.io/</link><description>The end of my mind...</description><atom:link href="https://death-of-rats.github.io/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2020 death-of-rats 
&lt;a rel="license" href="http://creativecommons.org/licenses/by/4.0/"&gt;&lt;img alt="Creative Commons Licence" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png" /&gt;&lt;/a&gt;&lt;br /&gt;This work is licensed under a &lt;a rel="license" href="http://creativecommons.org/licenses/by/4.0/"&gt;Creative Commons Attribution 4.0 International License&lt;/a&gt;.</copyright><lastBuildDate>Mon, 16 Mar 2020 04:59:50 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>0x09 Bootloader - read disk parameters</title><link>https://death-of-rats.github.io/posts/bootloader-read-disk-parameters/</link><dc:creator>death-of-rats</dc:creator><description>&lt;div&gt;&lt;p&gt;When BIOS finishes its job, it finds a bootable disk and loads the first sector
- the first 512 bytes. The magic 0xaa55 is the value marking bootable 510
bytes. But 510 bytes is not enough for a greedy programmer.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://death-of-rats.github.io/posts/bootloader-read-disk-parameters/"&gt;Read more…&lt;/a&gt; (4 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>asm</category><category>os</category><category>qemu</category><category>re</category><guid>https://death-of-rats.github.io/posts/bootloader-read-disk-parameters/</guid><pubDate>Fri, 10 May 2019 00:00:00 GMT</pubDate></item><item><title>0x08 Debug booting code in QEMU</title><link>https://death-of-rats.github.io/posts/gdb-qemu-booting/</link><dc:creator>death-of-rats</dc:creator><description>&lt;div&gt;&lt;p&gt;How to test and debug your own OS? For running one can use any of available
emulators or VMs. I choose &lt;strong&gt;QEMU&lt;/strong&gt;. But running isn't enough. Debugging is
very important - at least for me. In this post, I will build the 'OS' image,
run it and attach &lt;strong&gt;gdb&lt;/strong&gt; for debugging.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://death-of-rats.github.io/posts/gdb-qemu-booting/"&gt;Read more…&lt;/a&gt; (6 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>asm</category><category>os</category><category>qemu</category><category>re</category><guid>https://death-of-rats.github.io/posts/gdb-qemu-booting/</guid><pubDate>Fri, 03 May 2019 00:00:00 GMT</pubDate></item><item><title>0x07 Yasm: Echo with libc.</title><link>https://death-of-rats.github.io/posts/yasm-libc-echo/</link><dc:creator>death-of-rats</dc:creator><description>&lt;div&gt;&lt;p&gt;Let us write something with standard C functions like &lt;em&gt;printf&lt;/em&gt; or &lt;em&gt;scanf&lt;/em&gt;. What
I plan to learn from this is how to link the program with libc and do a little
refactor to program structure. &lt;/p&gt;
&lt;p&gt;&lt;a href="https://death-of-rats.github.io/posts/yasm-libc-echo/"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>asm</category><category>re</category><guid>https://death-of-rats.github.io/posts/yasm-libc-echo/</guid><pubDate>Mon, 29 Apr 2019 00:00:00 GMT</pubDate></item><item><title>0x06 Yasm: Hello World! ELF64</title><link>https://death-of-rats.github.io/posts/yasm-hello-world/</link><dc:creator>death-of-rats</dc:creator><description>&lt;div&gt;&lt;p&gt;First, try to write some x64 assembler program. I will use &lt;strong&gt;yasm&lt;/strong&gt; and &lt;strong&gt;ld&lt;/strong&gt;.
I have a few books about assembler, but not for 64-bit architecture. Lucky for
me, I found the "Introduction to 64 Bit Assembly Language Programming for Linux
and OS X" by Ray Seyfarth.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://death-of-rats.github.io/posts/yasm-hello-world/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>asm</category><category>re</category><guid>https://death-of-rats.github.io/posts/yasm-hello-world/</guid><pubDate>Fri, 26 Apr 2019 00:00:00 GMT</pubDate></item><item><title>0x05 Format String Attack</title><link>https://death-of-rats.github.io/posts/format-string-attack/</link><dc:creator>death-of-rats</dc:creator><description>&lt;div&gt;&lt;p&gt;When trying to take control over the program, one must sometimes alter
information stored on the stack. StackOverflow is one possibility. It is
constrained by the order of variables placed on the stack. Format String Attack
allows overstepping this constraint. This kind of attack uses &lt;em&gt;printf&lt;/em&gt;
functions family vulnerability. If one use &lt;em&gt;printf&lt;/em&gt; with a variable instead of
the format string, you have your window of opportunity. Of course, if you are
the one who puts data to this variable.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://death-of-rats.github.io/posts/format-string-attack/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>ctf</category><category>pwn</category><category>re</category><guid>https://death-of-rats.github.io/posts/format-string-attack/</guid><pubDate>Thu, 18 Apr 2019 22:00:00 GMT</pubDate></item><item><title>How my shell mess with me</title><link>https://death-of-rats.github.io/posts/how-my-shell-mess-with-me/</link><dc:creator>death-of-rats</dc:creator><description>&lt;div&gt;&lt;p&gt;Last week I spent 2h instead of 20 minutes on stack overflow challenge because my payload has some 
strange values in the middle of jump address. I was impressed by this challenge, and how it managed to
put some values between my bytes.
Imagine my mood when I realized that it wasn't some special power of the program. It was my shell doing
evil decoding behind the 
scene.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://death-of-rats.github.io/posts/how-my-shell-mess-with-me/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>shell</category><category>tools</category><guid>https://death-of-rats.github.io/posts/how-my-shell-mess-with-me/</guid><pubDate>Thu, 04 Apr 2019 22:00:00 GMT</pubDate></item><item><title>Icon 2018 CTF third challenge</title><link>https://death-of-rats.github.io/posts/icon_2018_ctf_third_challenge/</link><dc:creator>death-of-rats</dc:creator><description>&lt;div&gt;&lt;p&gt;The third challenge is a reverse engineering problem. The zipped package contains 3 files:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;crackme_baby
crackme.py
run.sh
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Python file contains definitions of simple math operations (add, sub, mul, div2, mod, inf). Let us
 disassemble crackme_baby file.
&lt;/p&gt;&lt;p&gt;&lt;a href="https://death-of-rats.github.io/posts/icon_2018_ctf_third_challenge/"&gt;Read more…&lt;/a&gt; (6 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>ctf</category><category>icon</category><category>re</category><category>reverse</category><category>writeups</category><guid>https://death-of-rats.github.io/posts/icon_2018_ctf_third_challenge/</guid><pubDate>Thu, 13 Sep 2018 22:00:00 GMT</pubDate></item><item><title>0x04 cpprest listener</title><link>https://death-of-rats.github.io/posts/cpprest-listener/</link><dc:creator>death-of-rats</dc:creator><description>&lt;div&gt;&lt;p&gt;I want to try to build simple REST server demo with &lt;em&gt;cpprestsdk&lt;/em&gt;. It is still experimental part of the library.&lt;/p&gt;
&lt;p&gt;Let's start the program. I want to listen on &lt;em&gt;localhost&lt;/em&gt; on port 9000 with relative path &lt;em&gt;/demo&lt;/em&gt;. For now, 
the program will handle only &lt;em&gt;GET&lt;/em&gt; and &lt;em&gt;POST&lt;/em&gt;. When the listener starts, we get a notification. 
&lt;em&gt;cpprestsdk&lt;/em&gt; uses &lt;code&gt;pplx::task&amp;lt;T&amp;gt;&lt;/code&gt; for composing asynchronous operations (&lt;code&gt;...then().then().wait()&lt;/code&gt;). The main
loop is very simple, we just &lt;code&gt;while&lt;/code&gt; infinitely.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://death-of-rats.github.io/posts/cpprest-listener/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>cpprest</category><category>http</category><category>rest</category><category>server</category><guid>https://death-of-rats.github.io/posts/cpprest-listener/</guid><pubDate>Thu, 31 May 2018 22:00:00 GMT</pubDate></item><item><title>0x03 building cpprest sample</title><link>https://death-of-rats.github.io/posts/building-cpprest-sample/</link><dc:creator>death-of-rats</dc:creator><description>&lt;div&gt;&lt;p&gt;One can install the &lt;a href="https://github.com/Microsoft/cpprestsdk"&gt;C++ REST SDK&lt;/a&gt; running 
&lt;code&gt;sudo apt install libcpprest-dev&lt;/code&gt;. Unfortunately after that my CMake couldn't find it. 
I have some other troubles with compiling a project with cpprest. So I change my mind and 
I built the library from the source 
(&lt;a href="https://github.com/Microsoft/cpprestsdk/wiki/How-to-build-for-Linux"&gt;instructions&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;To try the new toy I choose this &lt;a href="https://github.com/Microsoft/cpprestsdk/blob/master/Release/samples/BingRequest/bingrequest.cpp"&gt;sample&lt;/a&gt;.
&lt;/p&gt;&lt;p&gt;&lt;a href="https://death-of-rats.github.io/posts/building-cpprest-sample/"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cmake</category><category>cpp</category><category>rest</category><guid>https://death-of-rats.github.io/posts/building-cpprest-sample/</guid><pubDate>Sun, 27 May 2018 22:00:00 GMT</pubDate></item><item><title>0x02 travis + nikola</title><link>https://death-of-rats.github.io/posts/travis-nikola/</link><dc:creator>death-of-rats</dc:creator><description>&lt;div&gt;&lt;p&gt;One has running Nikola. One stores all ones work on GitHub and hosts it on the GitHub Pages. Nice. But 
do I really need to push my changes to the repo, and when I'm ready, build static pages and push them 
to the &lt;code&gt;master&lt;/code&gt;. And what if I'm not at my computer, what if I must change some typo. It would be 
nice if something could do this build and deploy the stuff for me.&lt;/p&gt;
&lt;p&gt;That is why I invite...&lt;/p&gt;
&lt;p&gt;&lt;a href="https://death-of-rats.github.io/posts/travis-nikola/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>nikola</category><category>travis</category><category>travis-ci</category><guid>https://death-of-rats.github.io/posts/travis-nikola/</guid><pubDate>Fri, 25 May 2018 00:00:00 GMT</pubDate></item></channel></rss>